软件生命周期
问题提出和规划 - 需求分析 - 软件设计 - 详细设计 - 程序编码 - 程序测试 - 运行维护

可重用-可扩展-可维护

结构稳定-可拓展-高内聚(模块功能区分明确)-低耦合


对象：抽象-封装-继承-多态

对象中的变量是成员变量 字段
Javabean 中的set get 才叫做属性


当字节码被JVM 加载的时候，方法区已经创建，static已经加载，xxx.class 已经加载
所以static 方法中不能使用this

static 的继承不是重写覆盖，而是隐藏。


引用数据类型： 类 / 接口 / 数组

多态
编译类型是运行类型的父类、或相同类型
两种形式：继承、接口实现
特点：屏蔽不同子类间的差异，把子类对象赋值给父类对象，在运行时才表现具体子类的特征。

注意: 对于静态方法，调用的是编译类型的方法，所以就是父类的方法。。。。。。
而且字段是没有多态的特征的，字段没有覆盖的概念，字段为自身所有，编译时期就已经确认了字段的调用。


执行顺序：
静态代码块: 静态成员随着字节码的加载也加载进JVM,用来初始化操作，加载资源文件，配置文件
main 方法
初始化代码块
构造器


装箱:
 Object[] objs = new Object[]{"1",2,3.0};



 包装类有缓存设计（享元模式）把一些简单的公用的东西进行缓存设计
 只要缓存中含有123 ，就会直接使用，但是缓存是有范围的，比如Integer是-128-127 ，如果是250那么就会重新创建
 Integer.valueOf(123)

 包装类间的比较使用equals 来比较，以为底层是进行了拆箱，比较值是否相等。


 模板方法设计模式：
 抽出一些公用的逻辑放在父类(模板方法final)，把一些不同的过程(具体的业务逻辑)放在子类覆盖实现(抽象方法 protected abstract 子类必须实现)。
 类似的HttpServet 中的doPost doGet


 接口是一种特殊的抽象类
    接口中的常量默认是全局静态常量 public static final
    接口中的方法默认都是public abstract 方法
    接口中不能定义普通方法

Java8后接口可以提供方法默认实现

    虚线方向箭头是实现    实线三角头是继承g



面向接口编程：多态
    把实现类赋值给接口，隐藏了不同实现类的特征



内部类：
   实例内部类的实例自动持有一个外部类实例的引用 OuterClass.this

匿名内部类：
多见于Android 中 new View.OnclickLisener() {

}
new 接口(){}


native 修饰符 表示可以跨平台语言调用，例如是调用了C++实现。

== 比较的是内存地址
equals 根据重写来确定比较内容，重写的重要性


常量池：
    编译常量池：存储字节码信息
    运行常量池：存放常量数据


字符串：
    双引号包裹的字符串，在编译时期就已经确定存储到常量池中. "ABCD" = "A" + "B" + "C" + "D" = "AB" + "CD" (编译器优化)
    使用String() 创建的对象是在运行期创建在堆内存中的.
    包含字符串变量或者方法的表达式，是在运行期才创建在堆内存的，因为编译器在编译期不知道变量的值。 getStr() + "BC" / temp + "BC"


