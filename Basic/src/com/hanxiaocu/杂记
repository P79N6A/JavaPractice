软件生命周期
问题提出和规划 - 需求分析 - 软件设计 - 详细设计 - 程序编码 - 程序测试 - 运行维护

可重用-可扩展-可维护

结构稳定-可拓展-高内聚(模块功能区分明确)-低耦合


对象：抽象-封装-继承-多态

对象中的变量是成员变量 字段
Javabean 中的set get 才叫做属性


当字节码被JVM 加载的时候，方法区已经创建，static已经加载，xxx.class 已经加载
所以static 方法中不能使用this

static 的继承不是重写覆盖，而是隐藏。


引用数据类型： 类 / 接口 / 数组

多态
编译类型是运行类型的父类、或相同类型
两种形式：继承、接口实现
特点：屏蔽不同子类间的差异，把子类对象赋值给父类对象，在运行时才表现具体子类的特征。

注意: 对于静态方法，调用的是编译类型的方法，所以就是父类的方法。。。。。。
而且字段是没有多态的特征的，字段没有覆盖的概念，字段为自身所有，编译时期就已经确认了字段的调用。


执行顺序：
静态代码块: 静态成员随着字节码的加载也加载进JVM,用来初始化操作，加载资源文件，配置文件
main 方法
初始化代码块
构造器


装箱:
 Object[] objs = new Object[]{"1",2,3.0};



 包装类有缓存设计（享元模式）把一些简单的公用的东西进行缓存设计
 只要缓存中含有123 ，就会直接使用，但是缓存是有范围的，比如Integer是-128-127 ，如果是250那么就会重新创建
 Integer.valueOf(123)

 包装类间的比较使用equals 来比较，以为底层是进行了拆箱，比较值是否相等。


 模板方法设计模式：
 抽出一些公用的逻辑放在父类(模板方法final)，把一些不同的过程(具体的业务逻辑)放在子类覆盖实现(抽象方法 protected abstract 子类必须实现)。
 类似的HttpServet 中的doPost doGet


 接口是一种特殊的抽象类
    接口中的常量默认是全局静态常量 public static final
    接口中的方法默认都是public abstract 方法
    接口中不能定义普通方法

Java8后接口可以提供方法默认实现

    虚线方向箭头是实现    实线三角头是继承g



面向接口编程：多态
    把实现类赋值给接口，隐藏了不同实现类的特征



内部类：
   实例内部类的实例自动持有一个外部类实例的引用 OuterClass.this

匿名内部类：
多见于Android 中 new View.OnclickLisener() {

}
new 接口(){}


native 修饰符 表示可以跨平台语言调用，例如是调用了C++实现。

== 比较的是内存地址
equals 根据重写来确定比较内容，重写的重要性


常量池：
    编译常量池：存储字节码信息
    运行常量池：存放常量数据


字符串：
    双引号包裹的字符串，在编译时期就已经确定存储到常量池中. "ABCD" = "A" + "B" + "C" + "D" = "AB" + "CD" (编译器优化)
    使用String() 创建的对象是在运行期创建在堆内存中的.
    包含字符串变量或者方法的表达式，是在运行期才创建在堆内存的，因为编译器在编译期不知道变量的值。 getStr() + "BC" / temp + "BC"



100M 带宽 =  100 * 1024 * kb/s(千位/秒) = 100 / 8 * 1024 * KB/s(千字节/秒) 下载速度

所以迅雷其实是开了多线程，抢占带宽，哈哈




Synchronized(X)
X 同步锁对象/同步监听对象
A.B线程，A获取到X,那么B将进入X的锁池中等待，
如果在A的同步方法中，执行了X.wait(),那么A释放X对象的锁，并进入X的等待池中，
同时将从锁池中随机选择一个，即B将获得锁，
如果在B的同步方法中执行了X.notify()，那么将会从X的等待池中取出A,放入X的锁池中，等待获取锁
当B执行完后释放锁，A获得锁，并继续执行同步方法。

1.两个线程同时访问锁，那么只有一个可以获取到，另一个放入锁池中
2.只有主动调用wait() 才会进入锁的等待池中
3.notify 只会将等待池中的线程放入锁池中，而不是直接获取锁


java5后
Lock() + Condition接口
condition.await()
condition.signal()


线程状态：
新建
可运行：就绪+Running
等待
时间等待
阻塞
终止状态：

sleep()不会释放锁
线程进入计时等待

结合线程：
join() 强制加入一个线程的执行，执行完，源线程继续



后台线程：守护线程 daemon
JVM的垃圾回收机制就是典型的后台线程
线程启动后无法修改其为后台线程，只有新建时设置setDaemon(true)；
前台线程创建的后台线程，当前台线程终止时，后台线程也会随之终止，但不一定是立即的。


线程的优先级：
获取执行的机会多一些，不和是否先执行有关系。
setPriority(1-10); 默认主线程5


线程礼让
yield() 暂停当前线程对象，并执行其他线程
线程进入就绪状态


线程安全的集合对象
ThreadLocal: 本地线程变量，安全模式
java8 线程池
java5 线程并发操作




数据结构
StringBuilder 默认大小16，自动扩容



ArrayList

LinkedList 双向/单向 list 和 队列 栈  的实现类 也不是线程安全的
List list= Collections.synchronizedList(new LinkedList())

Queue单向队列  Dueue 双向队列，队列只能操作队头和队尾

Stack 只能操作栈顶

Hash表 不连续的存储结构  扩容的时候会很慢，如果存在重复的数据，重新进行散列化

树结构： 范围查询，索引查询


java2 开始有了集合框架的概念
集合类中存储的是对象的引用，即内存地址


Vector 是同步的数组集合，线程安全
ArrayList 相反

线程安全
ArrayList list= Collections.synchronizedList(new ArrayList())


遍历删除：
迭代器遍历会开一个新的线程，复制数组，每次迭代完，会比较一下两个集合的个数是否相等
如果遍历过程中调用了集合的删除方法，那么迭代器线程中的集合数组个数不变，所以造成了报错。
应该调用迭代器的删除方法，从两个线程中同时删除元素，保证了同步。
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

但是迭代器遍历只能执行一边，因为迭代一边后，已经指向了最后一个元素，所以需要重新创建一个迭代器进行遍历。


泛型的擦除和转换，当把一个泛型对象赋值给不带泛型的对象，就造成了泛型擦除，然后再赋值给另一种泛型对象，虽然没报错，但是运行会有类型转换错误


Set: 线程不安全的集合
1.不允许重复数据
2.都不是线程安全的
Set s = Collections.sychronizedSet(Set对象)

HashSet：Hash算法->高效的等值查询
元素必须实现
1.hashCode
2.equals

LinkedHashSet 记录了元素的添加顺序，其他和HashSet相同

TreeSet 红黑树：SortSet | NavigableSet： 树结构->高效的范围查询
不保证添加顺序，但是元素会进行排序(默认自然排序，元素类型必须一样) 可范围查找
1.自然排序 元素实现comparable<T>
2.定制排序 传入一个实现了比较器的对象 x impl comparator<T>



Map： key 唯一 value不唯一
需要记录添加顺序那么就使用LinkedMap
通讯录使用TreeMap 自动排序


HashTable 是 hashMap的前身，是安全线程的，同Vector 和 ArrayList一样
Properties hashtable子类，key 和 value都是string
           一般数据库连接，资源属性文件加载


相同的Set内部其实都是一个对应的Map
HashSet ----> HashMap
TreeSet -----> TreeMap
....

堆污染：
当一个方法即使用泛型又使用可变参数的时候，就容易造成堆污染
如 ArrayList.asList方法   public static <T> List<T> asList(T...a)
